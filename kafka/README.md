# Kafka

Пакет для работы с Apache Kafka.

## Описание структур и интерфейсов

### Producer interface

Интерфейс, который используется для работы с 
кафка для передачи сообщений.

_Producer_ может быть **асинхронным**(вызывающая функция _Produce_ не ждёт подтверждений(Acknowledge) от Kafka) 
или же **синхронным**(вызывающая функция _Produce_ ждёт подтверждений(Acknowledge) от Kafka).

#### Produce

Отправляет сообщения в Kafka.

##### Пример использования

```go
err := someProducer.Produce(ctx, []kafka.Message{
    kafka.Message{
    },
})
if err != nil {
    // Обработка ошибки
}
```

#### SetCompletionCallback

##### Пример использования

```go
someProducer.SetCompletionCallback(func(msgs []kafka.Message, err error) {
    if err == nil {
        return
    }
    // Какие-то действия по обработке сообщений и ошибок
})
```

#### Close

##### Пример использования

```go
err := p.Close()
if err != nil {
    // Обработка ошибки
}
```

### NewAsyncProducer
Создаёт и инициализирует новый **асинхронный** продьюсер.

Особенность асинхронного продьюсера состоит в том, что после отправки сообщений(_Produce_) вызывающая сторона
(в данном случае -- клиент) не дожидается подтверждений о доставке сообщений в Kafka.

Для обработки ошибок и сообщений о доставке **обязательно** нужно установить callback при помощи
_SetCompletionCallback_, иначе информация о доставке будет **потеряна**. Для того, чтобы не забыть, перед каждой 
отправкой, в случае отсутствия CompletionCallback, будет написано сообщение
в лог с уровнем **WARN**.

### NewSyncProducer

Создаёт и инициализирует новый **синхронный** продьюсер.

Особенность синхронного продьюсера состоит в том, что после отправки сообщений(_Produce_) вызывающая сторона(в данном случае -- клиент)
дожидается подтверждений о доставке сообщений в Kafka. 

Для обработки ошибок и сообщений о доставке не нужно устанавливать callback при помощи _SetCompletionCallback_. Достаточно
только проверить ошибку и правильно её обработать(см. examples)

## Конфигурация Producer

Содержится в структуре ProducerConfig.

### Addr (producer.brokers)
Адреса брокеров Kafka.

### Balancer (producer.balancer)
Балансировщик, который используется для распределения сообщений
по партициям. 

**Рекомендуемое значение**: "roundrobin" (или пустое)

**Возможные значения**: "roundrobin", "murmur2", "crc32"

**Стандартное значение**: "roundrobin"

### Важно: MaxRetries (producer.max_retries)

Аналог опции 'retries' из librdkafka.

Максимальное количество попыток отправки сообщения, 
находящегося внутри очереди продьюсера, в случае возникновения ошибок.

**ВАЖНО**: [Список ошибок без повторной отправки](https://kafka.apache.org/protocol#protocol_error_codes)

**Рекомендуемое значение**: 3

**Стандартное значение**: 3

### Важно: QueueMaxMessages (producer.queue.max_messages):

Аналог опции 'queue.buffering.max.messages' из librdkafka.

Максимальное количество сообщений внутри _локальной_ очереди продьюсера.

В случае превышения порога, сразу же происходит отправка в Kafka.

**Рекомендуемое значение для синхронного продьюсера**: _10000_

**Стандартное значение**: _10000_

### Важно: QueueMaxBytesSize (producer.queue.max_bytes)

Аналог опции 'queue.buffering.max.kbytes' из librdkafka.

Максимальный размер _локальной_ очереди продьюсера в байтах(!)

В случае превышения порога, сразу же происходит отправка в Kafka

**Рекомендуемое значение для синхронного продьюсера**: 1048576 (1 МБ)

**Стандартное значение**: 1048576 (1 МБ)

### Важно: QueueBufferingTimeout (producer.queue.buffering_timeout)

Аналог опции 'queue.buffering.max.ms' из librdkafka.

Максимальное время ожидания наполнения _локального_ буфера продьюсера.

#### Как выбрать оптимальный баланс этой опции?

Когда выбирается значение опции, нужно исходить из следующих правил:

В асинхронном продьюсере: **Увеличение значения ведёт к увеличению использования RAM(RSS), уменьшение -- к увеличению использования CPU**

В синхронном продьюсере: **Увеличение значение ведёт к увеличению RTT(Round-Trip-Time), уменьшение -- к увеличению использования CPU**

Это возникает по следующим причинам:

1. Для асинхронного продьюсера: Увеличение памяти происходит из-за того, что объекты начинают дольше жить(время от аллокации 
   до сборки сборщиком мусора увеличивается). Из-за этого увеличивается количество потребляемой памяти(больше объектов --
   больше памяти).
   

2. Для асинхронного продьюсера: увеличение использования CPU происходит из-за того, что появляется больше I/O(Input/Output).
   На графиках CPU Usage можно будет увидеть увеличение System CPU Usage(то время, которое процессор проводит в syscall(системный вызов)).
   

3. Для синхронного продьюсера: увеличение RTT(Round-Trip-Time(время похода туда/обратно)) увеличивается из-за того,
что теперь пользователю, вызывающему _Produce_ приходится ждать время заполнения буфера + время сетевого похода. Увеличивается время заполнения буфера --
   увеличивается время ожидания конечного пользователя
   
4. Для синхронного продьюсера: уменьшение приводит к увеличению использования CPU по той же причине, что и в п.2

**Рекомендуемое значение для синхронного продьюсера**: 10ms

**Рекомендуемое значение для асинхронного продьюсера**: 100ms

**Стандартное значение**: 20ms

### ReadTimeout (producer.net.read_timeout)

Время чтения ответа по сети.

**Стандартное значение**: 3s

### WriteTimeout (producer.net.write_timeout)

Время записи данных в сеть(таймаут продьюсинга)

**Стандартное значение**: 3s

### DialTimeout (producer.net.dial_timeout)

Время подключения к брокерам кафка

**Стандартное значение**: 3s

### Важно: RequiredAcks (producer.required_acks)

Аналог опции 'request.required.acks' из librdkafka.

Количество подтверждений от брокеров для одного доставленного сообщения. 

Может иметь 3 значения

**0**: продьюсер не ожидает подтверждения от брокера (очень ненадёжная доставка, можно условно сравнить с асинхронной репликацией)

**-1**: продьюсер ожидает подтверждения от всех брокеров (очень надёжная доставка, можно условно сравнить с синхронной репликацией)

**1-N**: продьюсер ожидает подтверждения от N брокеров (надёжная доставка, чаще всего ACK от одного брокера хватает)

**Стандартное значение**: 1

**Рекомендуемое значение**: 1

### Compression (producer.compression)

Включение сжатия сообщений.

**Стандартное значение**: 0 (выключено)

### LogLevel (log.level)

Уровень логирования успешных сообщений.

**Стандартное значение**: 8 (выключено)

### ErrorLogLevel (log.errors_level)

Уровень логирования сообщений об ошибке

**Стандартное значение**: 8 (выключено)

### StatsConfig

Конфигурация для сбора статистики использования продьюсера Kafka.

#### StatsPrefix

Префикс для Prometheus метрик

**Стандартное значение**: "" (пустая строка)

#### Enabled

Включение сборки метрик

**Стандартное значение**: true (включено)

#### RefreshInterval

Интервал сбора метрик

**Стандартное значение**: 1s

### Circuit Breaker

Позволяет настроить Circuit Breaker, который будет срабатывать 
при превышении порога ошибок `max_fails` в заданный интервал времени `threshold`.

```yaml
breaker:
  enabled: true
  threshold: 5 # секунды
  max_fails: 10
```

### Пример использования
```go

cfg := kafka.NewProducerConfig("")

// Вызываем инициализацию конфигурации go-buns
config.InitOnce()

// Инициализируем Producer (в данном случае -- асинхронный)
producer := kafka.NewAsyncProducer(someZLogLogger, cfg)
```

## Рекомендации

### Рекомендации по использованию queue.* ручек
#### Синхронный продьюсер:

1. В случае большой нагрузки, следует чуть-чуть увеличить время заполнения очереди(например, с 10мс до 12мс). Это позволит
немножко сэкономить на использовании процессорных ресурсов засчёт увеличения времени отклика.
   

2. В случае небольшой нагрузки и когда доставка данных не особо влияет на бизнес-процессы, рекомендуется перейти на асинхронный
продьюсер с увеличенным queue.buffering_timeout(например, вместо 10мс с синхронного можно перейти на 100мс асинхронного).
   **Не забывайте обрабатывать callback о доставке!**
   
#### Асинхронный продьюсер:

1. Всегда выставляйте _callback_ о доставке при помощи _SetCompletionCallback_. Это позволит получать информацию о 

### Общие рекомендации
1. Всегда пишите несколько сообщений(ака Batching). В случае синхронного продьюсера это позволит меньше времени ожидать
подтверждения отправки.

### Рекомендуемая конфигурация

Асинхронный продьюсер:

```yaml
kafka:
  producer:
    brokers: '127.0.0.1:9092' # любой хост.
    balancer: "roundrobin"
    queue:
      max_messages: 10000
      max_bytes: 1048576
      buffering_timeout: 100ms # Увеличивайте или уменьшайте эту опцию в зависимости от нагрузки. В случае
      # вопросов напишите @a.petrukhin или в #sre_support
    net:
      read_timeout: 3s
      dial_timeout: 3s
      write_timeout: 3s
    stats:
       prefix: "some_prefix"
       enabled: true
       refresh_interval: 1s
    required_acks: 1
    compression: 0
  breaker:
     enabled: true
     threshold: 5
     max_fails: 10
```

Синхронный продьюсер:

```yaml
kafka:
  producer:
    brokers: '127.0.0.1:9092' # любой хост.
    balancer: "roundrobin"
    queue:
      max_messages: 10000
      max_bytes: 1048576
      buffering_timeout: 10ms # Увеличивайте или уменьшайте эту опцию в зависимости от нагрузки. В случае
      # вопросов напишите @a.petrukhin
    net:
      read_timeout: 3s
      dial_timeout: 3s
      write_timeout: 3s
      stats:
        prefix: "some_prefix"
        enabled: true
        refresh_interval: 1s
    required_acks: 1
    compression: 0
  breaker:
     enabled: true
     threshold: 5
     max_fails: 10
```